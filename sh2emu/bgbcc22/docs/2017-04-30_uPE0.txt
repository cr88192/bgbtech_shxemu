uPE:
* PE/COFF PE32 collapsed down into a single conjoined header.
** Implicitly, the start of the PE header is at a constant offset.
* Assumes FileOffset=RVA
** Simple Case: Loader simply reads image into memory.
* Data and BSS will have a 4kB alignment.
* Consider supporting a ProcessBaseOffset
** Access to Data/BSS will add the relevant PBO Register
** The PBO Register will be accessed as an offset relative to GBR (SH)

0000: WORD magic;		//MZ
003C: DWORD lfaNew;		//offset of PE header

struct uPeMainHeader
{
//0000: MZ Header
	WORD  mMagicMz;						//0000: MZ
	WORD  mResv0;						//0002: Reserved (0)
	DWORD mResv1;						//0004: Reserved (0)
	DWORD mResv2;						//0008: Reserved (0)
	DWORD mResv3;						//000C: Reserved (0)
	DWORD mResv4;						//0010: Reserved (0)
	DWORD mResv5;						//0014: Reserved (0)
	DWORD mResv6;						//0018: Reserved (0)
	DWORD mResv7;						//001C: Reserved (0)
	DWORD mResv8;						//0020: Reserved (0)
	DWORD mResv9;						//0024: Reserved (0)
	DWORD mResv10;						//0028: Reserved (0)
	DWORD mResv11;						//002C: Reserved (0)
	DWORD mResv12;						//0030: Reserved (0)
	DWORD mResv13;						//0034: Reserved (0)
	DWORD mResv14;						//0038: Reserved (0)
	DWORD lfaNew;						//003C: Address of PE header (0x0040)
//0040: PE/COFF Header
	DWORD mMagicPe;						//0040: PE\0\0 or 0x00004550
	WORD  mMachine;						//0044:
	WORD  mNumberOfSections;			//0046:
	DWORD mTimeDateStamp;				//0048: (Creation Time, Unix Time)
	DWORD mPointerToSymbolTable;		//004C: (Unused, 0)
	DWORD mNumberOfSymbols;				//0050: (Unused, 0)
	WORD  mSizeOfOptionalHeader;		//0054: Size of rest of header.
	WORD  mCharacteristics;				//0056:
//0058: Optional Header
	WORD  mMagic;						//0058: 0x010b=PE32
	BYTE  mMajorLinkerVersion;			//005A: (Ignore)
	BYTE  mMinorLinkerVersion;			//005B: (Ignore)
	DWORD mSizeOfCode;					//005C:
	DWORD mSizeOfInitializedData;		//0060:
	DWORD mSizeOfUninitializedData;		//0064:
	DWORD rvaAddressOfEntryPoint;		//0068:
	DWORD mBaseOfCode;					//006C:
	DWORD mBaseOfData;					//0070:
	DWORD mImageBase;					//0074:
	DWORD mSectionAlignment;			//0078:
	DWORD mFileAlignment;				//007C:
	WORD  mMajorOperatingSystemVersion;	//0080: (Ignore?)
	WORD  mMinorOperatingSystemVersion;	//0082: (Ignore?)
	WORD  mMajorImageVersion;			//0084: (Ignore?)
	WORD  mMinorImageVersion;			//0086: (Ignore?)
	WORD  mMajorSubsystemVersion;		//0088: (Ignore?)
	WORD  mMinorSubsystemVersion;		//008A: (Ignore?)
	DWORD mWin32VersionValue;			//008C: (Ignore?)
	DWORD mSizeOfImage;					//0090:
	DWORD mSizeOfHeaders;				//0094:
	DWORD mCheckSum;					//0098: (Ignore?)
	WORD  mSubsystem;					//009C: (Ignore?)
	WORD  mDllCharacteristics;			//009E: (Ignore?)
	DWORD mSizeOfStackReserve;			//00A0:
	DWORD mSizeOfStackCommit;			//00A4:
	DWORD mSizeOfHeapReserve;			//00A8: (NOMMU?)
	DWORD mSizeOfHeapCommit;			//00AC: (NOMMU?)
	DWORD mLoaderFlags;					//00B0: (Reserved, 0)
	DWORD mNumberOfRvaAndSizes;			//00B4:
//00B8: Data Directories
	DWORD rvaExportTable;				//00B8:
	DWORD szExportTable;				//00BC:
	DWORD rvaImportTable;				//00C0:
	DWORD szImportTable;				//00C4:
	DWORD rvaResourceTable;				//00C8:
	DWORD szResourceTable;				//00CC:
	DWORD rvaExceptionTable;			//00D0:
	DWORD szExceptionTable;				//00D4:
	DWORD rvaCertTable;					//00D8:
	DWORD szCertTable;					//00DC:
	DWORD rvaBaseRelocTable;			//00E0:
	DWORD szBaseRelocTable;				//00E4:

	DWORD rvaDebugData;					//00E8:
	DWORD szDebugData;					//00EC:
	DWORD rvaArchData;					//00F0:
	DWORD szArchData;					//00F4:
	DWORD rvaGlobalPtr;					//00F8:
	DWORD szGlobalPtr;					//00FC:
	DWORD rvaTlsTable;					//0100:
	DWORD szTlsTable;					//0104:
	DWORD rvaLoadConfigTable;			//0108:
	DWORD szLoadConfigTable;			//010C:
	DWORD rvaBoundImportTable;			//0110:
	DWORD szBoundImportTable;			//0114:
	DWORD rvaImportAddressTable;		//0118:
	DWORD szImportAddressTable;			//011C:
	DWORD rvaDelayImportTable;			//0120:
	DWORD szDelayImportTable;			//0124:
	DWORD rvaClrHeader;					//0128:
	DWORD szClrHeader;					//012C:
	DWORD rvaResvTable;					//0130:
	DWORD szResvTable;					//0134:
//0138:End of Header
};


Machine:
* x86-32:   0x014C
* x86-64:   0x8664
* ARM:      0x01C0
* SH-3:     0x01A2
* SH-DSP:   0x01A3
* SH-4:     0x01A6
* SH-5:     0x01A8
* BJX1-32:  0xB132
* BJX1-64:  0xB164

The main header is followed by sections.

struct uPeSectionHeader
{
	BYTE  mName[8];						//0000
	DWORD mVirtualSize;					//0008
	DWORD mVirtualAddress;				//000C
	DWORD mSizeOfRawData;				//0010
	DWORD mPointerToRawData;			//0014
	DWORD mPointerToRealocations;		//0018
	DWORD mPointerToLinenumbers;		//001C
	WORD  mNumberOfRealocations;		//0020
	WORD  mNumberOfLinenumbers;			//0022
	DWORD mCharacteristics;				//0024
	//28
};


=== Base Relocations ===

Relocations:
struct uPeRelocBlock
{
	DWORD rvaPage;		//RVA of Page to be relocated
	DWORD szBlock;		//Size of relocs in this block
};

The szBlock field is expressed in bytes. It includes the size of the RelocBlock header in addition to the associated reloc entries.

The relocations are given as 16 bit numbers:
* Low 12 bits: Offset within page.
* High 4 bits: Relocation Type
** 0: None
** 1: Fixup the high 16 bits of an address
** 2: Fixup the low 16 bits of an address
** 3: Fixup a 32-bit address
** 4: Fixup a 32 bit address split into a high and low part.
*** The following entry gives the address of the low part.
** 5: MIPS-specific fixup.
** 6: Reserved
** 7: Reserved
** 8: Reserved
** 9: MIPS-specific fixup.
*** uPE(SH): Fixup PBO Index Offset (16-bit Op)
** 10: Fixup a 64-bit address.
